const ebc = {
  // Uppercase Letters
  A: "00111100 01000010 10000001 10000001 11111111 10000001 10000001 10000001",
  B: "11111110 10000001 10000001 11111110 10000001 10000001 10000001 11111110",
  C: "01111110 10000001 10000000 10000000 10000000 10000000 10000001 01111110",
  D: "11111110 10000001 10000001 10000001 10000001 10000001 10000001 11111110",
  E: "11111111 10000000 10000000 11111110 10000000 10000000 10000000 11111110",
  F: "11111111 10000000 10000000 11111110 10000000 10000000 10000000 10000000",
  G: "01111110 10000001 10000000 10000000 10011110 10000001 10000001 01111110",
  H: "10000001 10000001 10000001 11111111 10000001 10000001 10000001 10000001",
  I: "01111110 00100010 00100010 00100010 00100010 00100010 01111110 00000000",
  J: "00111100 00010000 00010000 00010000 10010000 10010000 01100000 00000000",
  K: "10000001 10000010 10000100 10001000 10010000 10100000 11000000 10000000",
  L: "10000000 10000000 10000000 10000000 10000000 10000000 11111111 00000000",
  M: "10000001 11000011 10100101 10011001 10000001 10000001 10000001 10000001",
  N: "10000001 10010001 10100001 11000001 10000001 10000001 10000001 10000001",
  O: "01111100 10000010 10000001 10000001 10000001 10000010 10000001 01111110",
  P: "11111110 10000001 10000001 11111110 10000001 10000001 10000001 10000001",
  Q: "01111100 10000010 10000001 10000001 10010001 10001010 10000101 01111010",
  R: "11111110 10000001 10000001 11111110 10010001 10001001 10000101 10000001",
  S: "10000001 10000001 10000001 10000001 10000001 10000001 11111111 10000001",
  T: "01111110 00100010 00100010 00100010 00100010 00100010 01111110 00000000",
  U: "10000001 10000001 10000001 10000001 01000010 01000100 00111000 00000000",
  V: "11111111 00000100 00001000 00010000 00100000 01000000 11111111 00000000",
  W: "01111110 10000001 10000001 01111110 10000001 10000001 10000001 01111110",
  X: "10000001 01000010 00100100 00011000 00100100 01000010 10000001 00000000",
  Y: "11111110 10000001 10000001 11111110 00010000 00001000 00000100 00000000",
  Z: "11111111 00000001 00000010 00000100 00001000 00010000 00100000 11111111",

  // Lowercase Letters
  a: "00000000 00000000 01111000 10000010 01111110 10000010 10000010 01111111",
  b: "10000001 10000001 10111111 11000001 10000001 10000001 10000001 10111110",
  c: "00000000 00000000 01111110 10000000 10000000 10000000 10000000 01111110",
  d: "00000010 00000010 01111101 10000011 10000010 10000010 10000010 01111111",
  e: "00000000 00000000 01111100 10000010 11111111 10000000 10000000 01111110",
  f: "00011100 00100010 00100000 00111110 00100000 00100000 00100000 00100000",
  g: "00000000 01111111 10000010 10000010 01111110 00000010 10000010 01111100",
  h: "10000001 10000001 10111111 11000001 10000001 10000001 10000001 10000001",
  i: "00100000 00000000 00100000 00100000 00100000 00100000 00100000 00100000",
  j: "00010000 00000000 00010000 00010000 00010000 00010000 10010000 01100000",
  k: "10000001 10000010 10100000 11000000 10100000 10010000 10001000 10000001",
  l: "00100000 00100000 00100000 00100000 00100000 00100000 00100000 00100000",
  m: "00000000 00000000 10011010 10100101 10100101 10000001 10000001 10000001",
  n: "00000000 00000000 10111110 11000001 10000001 10000001 10000001 10000001",
  o: "00000000 00000000 01111100 10000010 10000010 10000010 10000010 01111110",
  p: "00000000 10111110 11000001 10000001 10000001 11000001 10111110 10000001",
  q: "00000000 01111101 10000010 10000010 10000010 01111101 00000010 00000011",
  r: "00000000 00000000 10111110 11000001 10000000 10000000 10000000 10000000",
  s: "00000000 00000000 01111110 10000000 01111100 00000010 10000010 01111100",
  t: "00100000 00100000 00111110 00100000 00100000 00100010 00100100 00011000",
  u: "00000000 00000000 10000010 10000010 10000010 10000010 10000010 01111111",
  v: "00000000 00000000 10000010 10000010 01000100 01000100 00101000 00010000",
  w: "00000000 00000000 10000001 10000001 10100101 10100101 01011010 00000000",
  x: "00000000 00000000 10000010 01000100 00101000 01000100 10000010 00000000",
  y: "00000000 00000000 10000010 10000010 01111110 00000010 10000010 01111100",
  z: "00000000 00000000 01111110 00000100 00001000 00010000 00100000 01111110",

  // Other Characters
  "?": "01111110 10000001 00000001 00000110 00001000 00000000 00001000 00000000",
  "@": "00111110 01000001 10011010 10100100 10100100 10011010 01000001 00111110",
  "!": "00100000 00100000 00100000 00100000 00100000 00100000 00100000 00100000",
  $: "00100000 00111000 01000100 01000100 01111100 00010010 00010010 01111000",
  "%": "11000000 11000100 00001000 00010000 00100000 01000011 10000110 00000011",
  "&": "00110000 01001000 01010000 00110000 01010101 01001001 00100010 00011100",
  "*": "00100000 01001000 00111110 00101000 01111110 01001000 00100000 00100000",
  "+": "00100000 00100000 00010000 00010000 01111110 00010000 00010000 00100000",
  ",": "00000000 00000000 00000000 00000000 00000000 00000000 00110000 00100000",
  "-": "00000000 00000000 00000000 00000000 01111110 00000000 00000000 00000000",
  ".": "00000000 00000000 00000000 00000000 00000000 00000000 00000000 00100000",
  "/": "00000000 00000010 00000100 00001000 00010000 00100000 01000000 10000000",

  // Digits
  0: "00111100 01000010 10000001 10000001 10000001 10000001 01000010 00111100",
  1: "00011000 00101000 00111000 00101000 00101000 00101000 00101000 01111110",
  2: "01111110 10000001 00000001 00000110 00011000 00100000 01000000 11111111",
  3: "01111110 10000001 00000001 00011110 00000001 00000001 10000001 01111110",
  4: "00000100 00001100 00010100 00100100 01000100 11111111 00000100 00000100",
  5: "11111111 10000000 10000000 11111110 00000001 00000001 10000001 01111110",
  6: "00011110 00100000 01000000 11111110 10000001 10000001 10000001 01111110",
  7: "11111111 00000001 00000010 00000100 00001000 00010000 00100000 01000000",
  8: "01111110 10000001 10000001 01111110 10000001 10000001 10000001 01111110",
  9: "01111110 10000001 10000001 01111111 00000001 00000001 10000001 01111110",
};

let sent = `                 I,m working with Greg on an engaging project that involves creating 8-byte characters reminiscent of the classic Commodore 64 style. Greg requested a set of binary representations for uppercase and lowercase letters, digits, and various ASCII characters. We collaborated to generate these character strings, carefully aligning them to form an 8x8 grid of dots a nod to the nostalgic design of the Commodore 64. This project is part of a larger exploration, where I join forces with David and Yuan. Together, we,re delving into the spatial and geometrical intuitions of large language models on tasks they are not specifically trained for. Greg,s implementation of the characters on the canvas using P5.js is just one facet of this gentle exploration. It,s an intriguing blend of creativity and technical prowess, showcasing the versatility of language models beyond their conventional applications.`;
let scroll = 0;
let sz = 10;
let cnv;
var foo = new p5.Speech(); // speech synthesis object
function setup() {
  cnv = createCanvas(880, 880);
  let cx = windowWidth / 2 - cnv.width / 2;
  let cy = windowHeight / 2 - cnv.height / 2;
  cnv.position(cx, cy);
  print(ebc["1"]);
  frameRate(13);
  foo.speak(sent);
}

function draw() {
  background(220);
  let sentind = scroll;

  for (let y = 0; y < 10; y++) {
    for (let x = 0; x < 10; x++) {
      // get letter
      let sentchr = sent[sentind];
      let ebchr = "";
      if (sentchr === " ") {
        ebchr =
          "00000000 00000000 00000000 00000000 00000000 00000000 00000000 000000000";
      } else {
        ebchr = ebc[sentchr];
      }

      // draw letter
      drawCharacter(x, y, ebchr);
      sentind++;
      if (sentind > sent.length - 1) {
        sentind = 0;
        scroll = 0;
      }
    }
  }
  scroll++;
}

function drawCharacter(x, y, lc) {
  let letind = 0;
  mystr = lc;
  cstr = mystr.replaceAll(" ", "");
  let strind = 0;
  for (let j = 0; j < 8; j++) {
    for (let i = 0; i < 8; i++) {
      if (cstr.charAt(strind) === "0") {
        fill(255);
      } else {
        fill(0);
      }
      rect(x * 88 + i * sz, y * 88 + j * sz, sz, sz);
      strind++;
    }
    fill(255, 0, 0);
    //rect((x*88) + 8*sz,(y*88) + j*sz,sz,sz);
  }

  letind++;
}
